📌 第2题：查找入职时间排名倒数第三的员工
sql
select * from employees
where hire_date = (
    select distinct hire_date 
    from employees 
    order by hire_date desc 
    limit 2,1
)
🔑 核心知识点

子查询：先查出倒数第三的入职日期，再匹配

DISTINCT：去重，防止相同日期干扰排名

LIMIT 2,1：跳过前2条，取1条（即第3条）

易错点：LIMIT偏移量从0开始，LIMIT 2,1 = 第3条

📌 第3题：查找当前薪水详情及部门编号
sql
select
    s.*,
    d.dept_no
from
    salaries as s
    join dept_manager as d on s.emp_no = d.emp_no
where
    s.to_date = '9999-01-01'
    and d.to_date = '9999-01-01';
🔑 核心知识点

多表连接：salaries与dept_manager通过emp_no关联

当前数据筛选：to_date = '9999-01-01'表示当前有效记录

表别名：as可省略（salaries s等效）

易错点：必须同时筛选两表的当前有效记录

📌 第4题：查找已分配部门员工的姓名与部门
sql
select 
    e.last_name,
    e.first_name,
    d.dept_no
from
    dept_emp d
    join employees e on d.emp_no = e.emp_no
order by
    d.emp_no
🔑 核心知识点

连接方向：以dept_emp为主表，确保结果均为已分配部门员工

字段顺序：last_name在前，first_name在后

排序关键：必须按emp_no排序，否则输出顺序错误导致判题失败

语义理解：“已分配部门” = INNER JOIN

📌 第5题：查找所有员工及部门（含未分配）
sql
SELECT 
    e.last_name,
    e.first_name,
    COALESCE(d.dept_no, 'None') as dept_no
FROM 
    employees e
    LEFT JOIN dept_emp d ON e.emp_no = d.emp_no
ORDER BY 
    e.emp_no;
🔑 核心知识点

左连接：LEFT JOIN保留所有员工，未分配部门则dept_no为NULL

NULL处理：COALESCE(字段, '默认值')将NULL转为友好显示

字段别名：as dept_no（as可省略）

易错点：题目要求未分配部门显示为'None'，而非NULL

